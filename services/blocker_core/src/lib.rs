pub mod schema; // generated by diesel print-schema

use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;
use diesel_migrations::{EmbeddedMigrations, MigrationHarness, embed_migrations};
use directories::ProjectDirs;

pub const MIGRATIONS: EmbeddedMigrations = embed_migrations!("./migrations");

pub mod models;
use models::*;

pub fn get_db_path() -> String {
    let proj = ProjectDirs::from("com", "Blocker", "Blocker").unwrap();
    let dir = proj.data_local_dir();
    std::fs::create_dir_all(dir).unwrap();
    let path = dir.join("blocker.db");
    path.to_string_lossy().to_string()
}

pub fn establish_connection() -> SqliteConnection {
    let db_path = get_db_path();
    SqliteConnection::establish(&db_path)
        .unwrap_or_else(|_| panic!("Error connecting to {}", db_path))
}

pub fn init_db() {
    let mut conn = establish_connection();
    conn.run_pending_migrations(MIGRATIONS)
        .expect("Migration failed");
}

pub fn create_group(
    conn: &mut SqliteConnection,
    id: &str,
    name: &str,
    enabled: bool,
) -> QueryResult<usize> {
    use crate::schema::groups;

    let new_group = NewGroup { id, name, enabled };

    diesel::insert_into(groups::table)
        .values(&new_group)
        .execute(conn)
}

pub fn add_domain(conn: &mut SqliteConnection, group_id: &str, domain: &str) -> QueryResult<usize> {
    use crate::schema::domains;

    let new_domain = NewDomain { group_id, domain };

    diesel::insert_into(domains::table)
        .values(&new_domain)
        .execute(conn)
}

pub fn add_schedule(
    conn: &mut SqliteConnection,
    group_id: &str,
    days: &str,
    start: &str,
    end: &str,
) -> QueryResult<usize> {
    use crate::schema::schedules;

    let new_schedule = NewSchedule {
        group_id,
        days,
        start,
        end,
    };

    diesel::insert_into(schedules::table)
        .values(&new_schedule)
        .execute(conn)
}

// Read Operations

pub fn get_groups(conn: &mut SqliteConnection) -> QueryResult<Vec<Group>> {
    use crate::schema::groups::dsl::*;
    groups.load::<Group>(conn)
}

pub fn get_domains(conn: &mut SqliteConnection, group_id_val: &str) -> QueryResult<Vec<Domain>> {
    use crate::schema::domains::dsl::*;
    domains
        .filter(group_id.eq(group_id_val))
        .load::<Domain>(conn)
}

pub fn get_schedule(
    conn: &mut SqliteConnection,
    group_id_val: &str,
) -> QueryResult<Option<Schedule>> {
    use crate::schema::schedules::dsl::*;
    schedules
        .filter(group_id.eq(group_id_val))
        .first::<Schedule>(conn)
        .optional()
}

// Update Operations

pub fn update_group(
    conn: &mut SqliteConnection,
    group_id_val: &str,
    new_name: &str,
    is_enabled: bool,
) -> QueryResult<usize> {
    use crate::schema::groups::dsl::*;
    diesel::update(groups.filter(id.eq(group_id_val)))
        .set((name.eq(new_name), enabled.eq(is_enabled)))
        .execute(conn)
}

pub fn delete_domains(conn: &mut SqliteConnection, group_id_val: &str) -> QueryResult<usize> {
    use crate::schema::domains::dsl::*;
    diesel::delete(domains.filter(group_id.eq(group_id_val))).execute(conn)
}

pub fn delete_schedule(conn: &mut SqliteConnection, group_id_val: &str) -> QueryResult<usize> {
    use crate::schema::schedules::dsl::*;
    diesel::delete(schedules.filter(group_id.eq(group_id_val))).execute(conn)
}

pub fn delete_group(conn: &mut SqliteConnection, group_id_val: &str) -> QueryResult<usize> {
    use crate::schema::groups::dsl::*;

    // Manual cascade delete
    let _ = delete_domains(conn, group_id_val);
    let _ = delete_schedule(conn, group_id_val);

    diesel::delete(groups.filter(id.eq(group_id_val))).execute(conn)
}
